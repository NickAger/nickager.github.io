---
layout: post
title: "Type erasure with AnyError"
tags: [Swift, iOS, Type Erasure]
date: 2016-03-07
excerpt_separator: <!--more-->
---
[`NADocumentPicker` ]({% post_url 2016-03-07-DocumentPicker %}) returns a [`Future` ](https://github.com/Thomvis/BrightFutures#examples) with the type:

```swift
Future<NSURL, AnyError>
```
why [`AnyError` ](https://github.com/NickAger/NACommonUtils/blob/master/NACommonUtils/Utilities/AnyError.swift)? [`AnyError` ](https://github.com/NickAger/NACommonUtils/blob/master/NACommonUtils/Utilities/AnyError.swift) solves the problem of providing a unified error type for a [`Future` ](https://github.com/Thomvis/BrightFutures#examples), so that when composing futures with `map`/`flatMap` the error type is the same and so can be propagated through the compositional chain.
<!--more-->

For example:

```swift
@IBAction func pickerButtonPressed(sender: UIButton) {
    let urlPickedfuture = NADocumentPicker.show(from: sender, parentViewController: self)
    let documentFuture = urlPickedfuture.flatMap { url in return MyDocument(url).open() }

    documentFuture.onSuccess { document in
        print("Opened document: \(document)")
    }
}
```

The [`Future` ](https://github.com/Thomvis/BrightFutures#examples) returned by `open()` has to have the same type error type to allow the compositional chain to transform `Future<NSURL, AnyError>` into Future<MyDocument, AnyError>`

Why not use [`ErrorType` ](https://github.com/apple/swift/blob/master/stdlib/public/core/ErrorType.swift#L20)? Unfortunately Swift does not allow protocols to be used as type parameters and generates the error:

> Using 'ErrorType' as a concrete type conforming to protocol 'ErrorType' is not allowed

## Type Erasure

This pattern of using `AnyError` ](https://github.com/NickAger/NACommonUtils/blob/master/NACommonUtils/Utilities/AnyError.swift) as generic concrete error type is known "type erasure". Another example from the Swift standard library is `AnySequence<T>`:

> AnySequence<T> wraps any sequence with element type T, conforms to SequenceType itself, and forwards all operations to the wrapped sequence. When handling the wrapper, the specific type of the wrapped sequence is fully hidden.

For example, `AnySequence` is used below to "erase" the origin of sequence generated from a [zip]({% post_url 2016-01-28-zip3 %}) operation:

```swift
let sequence1 = zip("hello".characters, "world".characters)
sequence1.dynamicType # Zip2Sequence<String.CharacterView, String.CharacterView>.Type

let sequence2 = AnySequence(sequence1)
sequence2.dynamicType # AnySequence<(Character, Character)>.Type
```

## See also

* [Cannot return a future with a different error type by chaining calls with flatMap](https://github.com/Thomvis/BrightFutures/issues/115)
* Cocoaphony: [A Little Respect for AnySequence](http://robnapier.net/erasure)
* [Define a Swift protocol which requires a specific type of sequence](http://stackoverflow.com/questions/33843038/define-a-swift-protocol-which-requires-a-specific-type-of-sequence)
* [`AnySequence` type erasure for `Zip3Sequence`]({% post_url 2016-01-28-zip3 %})
* [Superpowers / obfuscation with map & flatMap]({% post_url 2016-02-02-flatmap-and-obfuscation})
